// src/socket/handlers/buzzHandlers.js
const { Room, defaultRoomOptions } = require('../../models/Room'); // Importer defaultRoomOptions
const logger = require('../../utils/logger');

// Stockage des p√©riodes de gr√¢ce pour les buzzers
const buzzerGracePeriods = {};

// Stockage des latences moyennes par joueur
const playerLatencies = {};

/**
 * Attache les √©v√©nements de buzz au socket
 * @param {Socket} socket - Socket client
 * @param {Server} io - Instance Socket.IO
 */
function attachEvents(socket, io) {
  // √âv√©nement buzz d'un joueur
  socket.on('buzz', (data, callback) => handleBuzz(socket, io, data, callback));

  // R√©initialisation des buzzers par l'admin
  socket.on('reset_buzzer', (data) => handleResetBuzzer(socket, io, data));

  // D√©sactiver temporairement le buzzer pour un joueur
  socket.on('disable_buzzer', (data) => handleDisableBuzzer(socket, io, data));

  // Ping pour mesurer la latence
  socket.on('ping', (timestamp, callback) => handlePing(socket, timestamp, callback));

  // Nettoyage lors de la d√©connexion
  socket.on('disconnect', () => {
    cleanupPlayerData(socket.id);
  });
}

/**
 * Nettoyage complet des donn√©es d'un joueur d√©connect√©
 */
function cleanupPlayerData(socketId) {
  // Nettoyer les donn√©es de latence
  if (playerLatencies[socketId]) {
    delete playerLatencies[socketId];
  }

  // Nettoyer des p√©riodes de gr√¢ce en cours
  for (const roomCode in buzzerGracePeriods) {
    if (buzzerGracePeriods[roomCode] && buzzerGracePeriods[roomCode].candidates) {
      buzzerGracePeriods[roomCode].candidates = buzzerGracePeriods[roomCode].candidates.filter(
        candidate => candidate.socketId !== socketId
      );
      
      // Si plus de candidats, nettoyer compl√®tement
      if (buzzerGracePeriods[roomCode].candidates.length === 0) {
        delete buzzerGracePeriods[roomCode];
        logger.info('CLEANUP', 'P√©riode de gr√¢ce nettoy√©e apr√®s d√©connexion', { socketId, roomCode });
      }
    }
  }
}

/**
 * G√®re le ping pour mesurer la latence
 */
function handlePing(socket, clientTimestamp, callback) {
  const serverTimestamp = Date.now();
  const latency = Math.max(0, serverTimestamp - clientTimestamp);
  
  // üöÄ FILTRER LES PINGS ABERRANTS
  // Ignorer les latences impossibles (>2000ms = connexion morte)
  if (latency > 2000) {
    logger.warn('PING', 'Latence aberrante ignor√©e', {
      socketId: socket.id,
      latency,
      clientTimestamp,
      serverTimestamp
    });
    callback({ serverTimestamp, latency, ignored: true });
    return;
  }
  
  // üöÄ AM√âLIORATION 7: Gestion des pics de latence temporaires
  let shouldIgnoreSpike = false;
  
  // Si on a d√©j√† des donn√©es de latence, v√©rifier les pics
  if (playerLatencies[socket.id] && playerLatencies[socket.id].average) {
    const currentAverage = playerLatencies[socket.id].average;
    const deviation = Math.abs(latency - currentAverage);
    const isSignificantSpike = deviation > (currentAverage * 1.5) && latency > 500;
    
    // Ignorer les pics isol√©s significatifs
    if (isSignificantSpike) {
      shouldIgnoreSpike = true;
      logger.warn('PING', 'Pic de latence temporaire ignor√©', {
        socketId: socket.id,
        latency,
        currentAverage,
        deviation,
        spikeThreshold: currentAverage * 1.5
      });
      
      callback({ serverTimestamp, latency, ignored: true, reason: 'spike' });
      return;
    }
  }
  
  // Initialiser ou mettre √† jour la latence moyenne (moyenne mobile sur 3 valeurs)
  if (!playerLatencies[socket.id]) {
    playerLatencies[socket.id] = {
      values: [latency],
      average: latency,
      spikeCount: 0 // Compteur de pics pour statistiques
    };
  } else {
    const values = playerLatencies[socket.id].values;
    values.push(latency);
    if (values.length > 3) values.shift(); // Garder seulement les 3 derni√®res
    playerLatencies[socket.id].average = values.reduce((a, b) => a + b, 0) / values.length;
    
    // Incr√©menter le compteur de pics si c'√©tait un pic ignor√©
    if (shouldIgnoreSpike) {
      playerLatencies[socket.id].spikeCount = (playerLatencies[socket.id].spikeCount || 0) + 1;
    }
  }

  callback({ serverTimestamp, latency });
}

/**
 * Calcule la p√©riode de gr√¢ce adaptative bas√©e sur les latences de la salle
 */
function calculateGracePeriod(roomCode) {
  const room = Room.get(roomCode);
  if (!room) return 300; // Fallback par d√©faut

  const roomLatencies = [];
  
  // Collecter les latences des joueurs de cette salle
  for (const socketId in room.players) {
    if (playerLatencies[socketId]) {
      roomLatencies.push(playerLatencies[socketId].average);
    }
  }

  if (roomLatencies.length === 0) return 300; // Pas de donn√©es de latence

  // üöÄ FILTRAGE DES LATENCES ABERRANTES
  // √âliminer les connexions non viables (> 1000ms) et n√©gatives
  const validLatencies = roomLatencies.filter(lat => lat >= 0 && lat <= 1000);
  
  // Si toutes les latences sont aberrantes, fallback
  if (validLatencies.length === 0) {
    logger.warn('GRACE_PERIOD', 'Toutes les latences sont aberrantes, fallback 300ms', {
      roomCode,
      originalLatencies: roomLatencies,
      playerCount: roomLatencies.length
    });
    return 300;
  }

  // Si on a √©limin√© des latences aberrantes, le signaler
  if (validLatencies.length < roomLatencies.length) {
    const filteredOut = roomLatencies.filter(lat => lat < 0 || lat > 1000);
    logger.info('GRACE_PERIOD', 'Latences aberrantes filtr√©es', {
      roomCode,
      filteredOut,
      validCount: validLatencies.length,
      totalCount: roomLatencies.length
    });
  }

  const maxLatency = Math.max(...validLatencies);
  const minLatency = Math.min(...validLatencies);
  const spread = maxLatency - minLatency;

  // üöÄ AM√âLIORATION 3: P√©riode de gr√¢ce adapt√©e au nombre de joueurs
  const playerCount = Object.keys(room.players).filter(id => !room.players[id].isAdmin).length;
  
  // Base adapt√©e au nombre de joueurs
  let basePeriod;
  if (playerCount <= 2) basePeriod = 150;      // Peu de joueurs = p√©riode courte
  else if (playerCount <= 4) basePeriod = 200; // Nombre moyen
  else if (playerCount <= 6) basePeriod = 250; // Beaucoup de joueurs
  else basePeriod = 300;                       // Tr√®s grande salle

  // Plafond adapt√© aussi
  const maxPeriod = playerCount > 6 ? 600 : 500;
  
  // Calcul final : base + spread/2, plafonn√©e selon le nombre de joueurs
  const gracePeriod = Math.min(basePeriod + (spread / 2), maxPeriod);
  
  logger.info('GRACE_PERIOD', 'P√©riode de gr√¢ce calcul√©e', {
    roomCode,
    gracePeriod,
    basePeriod,
    maxPeriod,
    spread,
    minLatency,
    maxLatency,
    playerCount,
    validPlayerCount: validLatencies.length,
    totalPlayerCount: roomLatencies.length,
    wasFiltered: validLatencies.length < roomLatencies.length
  });

  return gracePeriod;
}

/**
 * Calcule le seuil d'√©galit√© adaptatif selon la qualit√© des connexions
 */
function calculateEqualityThreshold(validLatencies) {
  if (validLatencies.length === 0) return 50; // Fallback par d√©faut
  
  const averageLatency = validLatencies.reduce((a, b) => a + b, 0) / validLatencies.length;
  
  // Seuil adaptatif : connexions rapides = seuil strict, connexions lentes = seuil plus permissif
  if (averageLatency < 50) return 30;      // Connexions tr√®s rapides
  if (averageLatency < 150) return 50;     // Connexions normales
  if (averageLatency < 300) return 75;     // Connexions moyennes
  return 100;                              // Connexions lentes
}

/**
 * G√®re un buzz d'un joueur
 */
function handleBuzz(socket, io, data, callback) {
  const { roomCode, clientTimestamp = Date.now() } = data;

  try {
    logger.info('BUZZ', 'Tentative de buzz', {
      socketId: socket.id,
      roomCode
    });

    // V√©rifier si la salle existe
    const room = Room.get(roomCode);
    if (!room) {
      return callback({ error: 'Salle inexistante' });
    }

    // --- LOGIQUE G√âN√âRIQUE : V√©rifier si la piste/question est d√©j√† r√©solue ---
    // Cette logique fonctionne avec ou sans Spotify
    if (room.trackIsFullyFound) {
        logger.info('BUZZ', `Buzz rejet√© pour ${socket.id} dans ${roomCode}: piste/question d√©j√† r√©solue.`);
        const firstBuzzerPseudo = room.players[room.firstBuzz]?.pseudo;
        return callback({ error: 'La piste/question a d√©j√† √©t√© trouv√©e.', lateAttempt: true, buzzedBy: firstBuzzerPseudo });
    }
    // --- Fin V√©rification ---

    // V√©rifier si la partie est en pause
    if (room.paused) {
      return callback({ error: 'La partie est en pause' });
    }

    // Si un buzz est d√©j√† valid√©, traiter normalement
    if (room.firstBuzz) {
      // *** V√âRIFIER que le joueur qui a firstBuzz n'est pas en p√©nalit√© ***
      const firstBuzzer = room.players[room.firstBuzz];
      if (firstBuzzer && firstBuzzer.buzzed) {
        // Le premier buzzer est toujours actif (pas encore jug√© ou en p√©nalit√©)
        const buzzingPlayer = firstBuzzer.pseudo || 'Quelqu\'un';
        return callback({
          error: `${buzzingPlayer} a √©t√© plus rapide !`,
          buzzedBy: buzzingPlayer,
          lateAttempt: true
        });
      } else {
        // Le premier buzzer n'est plus actif, r√©initialiser firstBuzz
        logger.info('BUZZ', 'Premier buzzer inactif, r√©initialisation', { 
          roomCode, 
          previousFirstBuzz: room.firstBuzz 
        });
        Room.resetBuzz(roomCode);
        // Continuer le traitement normal du buzz
      }
    }

    // V√©rification du joueur
    if (!room.players[socket.id]) {
      return callback({ error: 'Joueur introuvable dans la salle' });
    }

    // üöÄ AM√âLIORATION 2: Fallback latence plus r√©aliste
    const playerLatency = playerLatencies[socket.id]?.average || 150; // 150ms au lieu de 0ms
    
    // üöÄ AM√âLIORATION 1: Utiliser timestamp serveur pour √©viter d√©sync horloge
    const serverTimestamp = Date.now();

    // P√âRIODE DE GR√ÇCE: si c'est le premier buzz, ouvrir une fen√™tre d'opportunit√©
    if (!buzzerGracePeriods[roomCode]) {
      // üöÄ AM√âLIORATION 4: Recalculer √† chaque nouveau buzz
      const gracePeriod = calculateGracePeriod(roomCode);
      
      // Premier buzz re√ßu - cr√©er une p√©riode de gr√¢ce
      buzzerGracePeriods[roomCode] = {
        candidates: [{
          socketId: socket.id,
          pseudo: room.players[socket.id].pseudo,
          timestamp: clientTimestamp,
          serverTimestamp: serverTimestamp,
          latency: playerLatency,
          compensatedTime: serverTimestamp + playerLatency // üöÄ AM√âLIORATION 1: Temps serveur compens√©
        }],
        gracePeriod: gracePeriod,
        startTime: serverTimestamp // Pour debugging
      };

      // Confirmer r√©ception sans d√©signer de gagnant encore
      callback({ received: true });

      logger.info('BUZZ', 'P√©riode de gr√¢ce d√©marr√©e', {
        socketId: socket.id,
        roomCode,
        pseudo: room.players[socket.id].pseudo,
        latency: playerLatency,
        gracePeriod: gracePeriod,
        compensatedTime: serverTimestamp + playerLatency
      });

      // D√©marrer un timer adaptatif avant de d√©terminer le gagnant
      setTimeout(() => {
        processBuzzers(roomCode, io);
      }, gracePeriod);

      return;
    }

    // Si on est d√©j√† dans une p√©riode de gr√¢ce, ajouter ce buzz √† la liste
    buzzerGracePeriods[roomCode].candidates.push({
      socketId: socket.id,
      pseudo: room.players[socket.id].pseudo,
      timestamp: clientTimestamp,
      serverTimestamp: serverTimestamp,
      latency: playerLatency,
      compensatedTime: serverTimestamp + playerLatency // üöÄ AM√âLIORATION 1: Temps serveur compens√©
    });

    logger.info('BUZZ', 'Buzz ajout√© pendant la p√©riode de gr√¢ce', {
      socketId: socket.id,
      roomCode,
      pseudo: room.players[socket.id].pseudo,
      candidateCount: buzzerGracePeriods[roomCode].candidates.length,
      latency: playerLatency,
      compensatedTime: serverTimestamp + playerLatency
    });

    callback({ received: true });

  } catch (error) {
    // En cas d'erreur, nettoyer les ressources
    if (buzzerGracePeriods[roomCode]) {
      delete buzzerGracePeriods[roomCode];
    }

    logger.error('BUZZ', 'Erreur de buzz', error);
    return callback({ error: 'Erreur interne lors du buzz' });
  }
}

/**
 * Traite les buzzers apr√®s la p√©riode de gr√¢ce avec compensation de latence
 */
function processBuzzers(roomCode, io) {
  try {
    // V√©rifier que les donn√©es n√©cessaires existent toujours
    const room = Room.get(roomCode);
    if (!buzzerGracePeriods[roomCode] || !room) {
      // Nettoyage par s√©curit√©
      if (buzzerGracePeriods[roomCode]) delete buzzerGracePeriods[roomCode];
      return;
    }

    const candidates = buzzerGracePeriods[roomCode].candidates;

    logger.info('BUZZ_PROCESS', 'Traitement des buzzers apr√®s p√©riode de gr√¢ce', {
      roomCode,
      candidateCount: candidates.length,
      candidates: candidates.map(c => ({
        pseudo: c.pseudo,
        latency: c.latency,
        compensatedTime: c.compensatedTime
      }))
    });

    if (candidates.length === 0) {
      delete buzzerGracePeriods[roomCode];
      return;
    }

    // Filtrer les candidats encore valides (joueurs toujours connect√©s)
    const validCandidates = candidates.filter(c => room.players[c.socketId]);

    if (validCandidates.length === 0) {
      logger.info('BUZZ_PROCESS', 'Aucun candidat valide pour le buzz', { roomCode });
      delete buzzerGracePeriods[roomCode];
      return;
    }

    // Trier par temps compens√© (server timestamp + latence)
    validCandidates.sort((a, b) => a.compensatedTime - b.compensatedTime);

    let winner = validCandidates[0];

    // üöÄ AM√âLIORATION 5: Seuil d'√©galit√© adaptatif
    const roomLatencies = validCandidates.map(c => c.latency);
    const equalityThreshold = calculateEqualityThreshold(roomLatencies);

    // V√©rifier s'il y a √©galit√© avec seuil adaptatif
    const second = validCandidates[1];
    if (second && Math.abs(winner.compensatedTime - second.compensatedTime) < equalityThreshold) {
      
      // D√©partage al√©atoire entre les ex-aequo
      const tied = validCandidates.filter(c => 
        Math.abs(c.compensatedTime - winner.compensatedTime) < equalityThreshold
      );
      
      winner = tied[Math.floor(Math.random() * tied.length)];
      
      logger.info('BUZZ_PROCESS', 'D√©partage al√©atoire appliqu√©', {
        roomCode,
        tiedCount: tied.length,
        winner: winner.pseudo,
        equalityThreshold,
        timeDifference: second ? Math.abs(winner.compensatedTime - second.compensatedTime) : 'N/A'
      });
    }

    // D√©signer le gagnant
    Room.setFirstBuzz(roomCode, winner.socketId);
    room.players[winner.socketId].buzzed = true;

    const buzzData = {
      buzzedBy: winner.pseudo,
      playerId: winner.socketId,
      roomCode,
      _debug: {
        latency: winner.latency,
        compensatedTime: winner.compensatedTime,
        candidateCount: validCandidates.length,
        equalityThreshold,
        wasRandomTieBreak: second && Math.abs(winner.compensatedTime - second.compensatedTime) < equalityThreshold
      }
    };

    Room.setLastBuzz(roomCode, buzzData);
    io.to(roomCode).emit('buzzed', buzzData);

    // --- NOUVEAU : √âmettre un √©v√©nement g√©n√©rique pour les int√©grations externes ---
    io.to(roomCode).emit('player_buzzed', {
      roomCode,
      playerId: winner.socketId,
      pseudo: winner.pseudo
    });

    logger.info('BUZZ_PROCESS', 'Gagnant d√©sign√© apr√®s p√©riode de gr√¢ce', {
      roomCode,
      winner: winner.pseudo,
      socketId: winner.socketId,
      latency: winner.latency,
      compensatedTime: winner.compensatedTime,
      candidateCount: validCandidates.length,
      equalityThreshold
    });

    // Nettoyer
    delete buzzerGracePeriods[roomCode];
  } catch (error) {
    logger.error('BUZZ_PROCESS', 'Erreur lors du traitement des buzzers', error);

    // Nettoyage en cas d'erreur
    if (buzzerGracePeriods[roomCode]) {
      delete buzzerGracePeriods[roomCode];
    }
  }
}

/**
 * G√®re la r√©initialisation des buzzers
 */
function handleResetBuzzer(socket, io, data) {
  try {
    const { roomCode } = data;
    const room = Room.get(roomCode);

    if (!room) {
      logger.warn('RESET_BUZZER', 'Salle non trouv√©e pour r√©initialisation', { roomCode });
      return;
    }
    // V√©rifier que c'est bien l'admin qui demande la r√©initialisation
    if (room.adminId !== socket.id) {
       logger.warn('RESET_BUZZER', 'Tentative de r√©initialisation non-admin', { roomCode, socketId: socket.id });
      return;
    }

    logger.info('RESET_BUZZER', 'R√©initialisation des √©tats de buzz des joueurs', { roomCode });
    // R√©initialiser l'√©tat de buzz pour tous les joueurs
    for (let id in room.players) {
      if (room.players[id]) { // V√©rification de s√©curit√©
        room.players[id].buzzed = false;
      }
    }

    // R√©initialiser le premier/dernier buzz dans la salle
    logger.info('RESET_BUZZER', 'Nettoyage des donn√©es de buzz de la salle', { roomCode });
    Room.clearBuzz(roomCode); // R√©initialise firstBuzz et lastBuzz

    // Nettoyer les p√©riodes de gr√¢ce en cours
    if (buzzerGracePeriods[roomCode]) {
      delete buzzerGracePeriods[roomCode];
    }

    // *** AJOUT IMPORTANT ***
    // √âmettre √† nouveau l'√©tat des joueurs apr√®s avoir mis buzzed=false
    logger.info('RESET_BUZZER', '√âmission de update_players apr√®s r√©initialisation des flags buzzed', { roomCode });
    io.to(roomCode).emit('update_players', room.players);

    // √âmettre l'√©v√©nement sp√©cifique de r√©initialisation pour l'UI client
    logger.info('RESET_BUZZER', '√âmission de l\'√©v√©nement reset_buzzer', { roomCode });
    io.to(roomCode).emit('reset_buzzer'); // Garder cet √©v√©nement

    logger.info('RESET_BUZZER', 'Buzzers r√©initialis√©s avec succ√®s', { roomCode });
  } catch (error) {
    logger.error('RESET_BUZZER', 'Erreur lors de la r√©initialisation des buzzers', error);
  }
}

/**
 * G√®re la d√©sactivation temporaire du buzzer pour un joueur (apr√®s mauvaise r√©ponse)
 */
function handleDisableBuzzer(socket, io, data) {
  try {
    // On attend juste roomCode et playerId, la dur√©e vient des options de la salle
    const { roomCode, playerId } = data;
    const room = Room.get(roomCode);
    
    if (!room) return logger.warn('DISABLE_BUZZER', 'Salle non trouv√©e', { roomCode });
    if (room.adminId !== socket.id) return logger.warn('DISABLE_BUZZER', 'Tentative non-admin', { roomCode, socketId: socket.id });
    if (!room.players[playerId]) return logger.warn('DISABLE_BUZZER', 'Joueur non trouv√©', { roomCode, playerId });
    
    const options = room.options || defaultRoomOptions;
    const penaltyDurationSeconds = options.penaltyDelay; // Utiliser la dur√©e des options
    
    // Ne rien faire si la p√©nalit√© est de 0 seconde
    if (penaltyDurationSeconds <= 0) {
        logger.info('DISABLE_BUZZER', 'P√©nalit√© d√©sactiv√©e (0s), pas de blocage.', { roomCode, playerId });
        return;
    }

    // Marquer le joueur comme buzzed (pour le bloquer visuellement/logiquement)
    room.players[playerId].buzzed = true;
    
    // Informer tous les joueurs de la salle (pour m√†j UI)
    io.to(roomCode).emit('update_players', room.players);
    
    // Notifier le joueur concern√© de la d√©sactivation temporaire (pour l'UI)
    const durationMs = penaltyDurationSeconds * 1000;
    io.to(playerId).emit('buzzer_disabled', { duration: durationMs });
    
    logger.info('DISABLE_BUZZER', 'Buzzer temporairement d√©sactiv√©', {
      roomCode,
      playerId,
      duration: penaltyDurationSeconds,
      pseudo: room.players[playerId].pseudo
    });

    // R√©activer apr√®s la dur√©e sp√©cifi√©e
    setTimeout(() => {
      try {
        // Re-v√©rifier l'existence de la salle et du joueur
        const currentRoom = Room.get(roomCode);
        if (currentRoom && currentRoom.players[playerId]) {
          // Ne r√©activer que si le joueur est toujours marqu√© comme 'buzzed' (√©vite conflits)
          if (currentRoom.players[playerId].buzzed) {
              currentRoom.players[playerId].buzzed = false;
              
              // AJOUT ICI: Si c'est ce joueur qui avait le firstBuzz, le r√©initialiser
              if (currentRoom.firstBuzz === playerId) {
                  Room.resetBuzz(roomCode); // R√©initialiser firstBuzz et lastBuzz
              }
              
              io.to(roomCode).emit('update_players', currentRoom.players);
              io.to(playerId).emit('buzzer_enabled'); // Informer le joueur qu'il est r√©activ√©
              
              logger.info('DISABLE_BUZZER', 'Buzzer r√©activ√© apr√®s d√©lai', {
                roomCode,
                playerId,
                duration: penaltyDurationSeconds,
                pseudo: currentRoom.players[playerId].pseudo
              });
          }
        }
      } catch (timeoutError) {
        logger.error('DISABLE_BUZZER', 'Erreur dans le timeout de r√©activation', timeoutError);
      }
    }, durationMs);
    
  } catch (error) {
    logger.error('DISABLE_BUZZER', 'Erreur lors de la d√©sactivation', error);
  }
}

module.exports = {
  attachEvents,
  handleResetBuzzer, // Exporter si utilis√© par playerHandlers
  handleDisableBuzzer, // Exporter si utilis√© par playerHandlers
  // buzzerGracePeriods n'a pas besoin d'√™tre export√©
};